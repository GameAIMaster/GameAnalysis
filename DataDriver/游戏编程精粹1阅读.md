游戏在启动的时候会利用文本分析器从文件中读取数据，而不是写在代码中，数据和逻辑的分离，能够方便设计人员和测试进行各种新的尝试，新的测试。文本文件解析系统是必不可少的工具。

​	最低标准：不要硬编码常量，把常量放到文本文件中，避免编译代码。

​	**杜绝**硬编码，假定任何东西都可能改变。核心部分抽象成概念，而不是设计文档中写的局限性的行为。

​	将控制流写成脚本：**脚本**是一种在代码外定义行为的方法。什么应该写在脚本中?切场景，简单的因果逻辑，搜索的完成状态或者环境触发器。什么写在代码里？通用的概念抽象，软件的运行框架，各个系统架构。游戏编程精粹中说不适合在脚本中编写复杂逻辑，受限于当时脚本语言无法调试。当脚本语言方便易用时可以充当有限状态机处理游戏逻辑，在UE4中蓝图则是为设计师提供了可视化处理游戏逻辑的方案，当然会有性能上的损耗，但是符合安德比尔定律。在天龙项目中策划则只能通过文档来设计游戏，这是一个缺点，应将基本的控制逻辑接口提供出来供策划修改。什么是基本的控制逻辑？通过我在项目中以及使用UE4引擎的经验归纳来讲没有复杂的逻辑结构，只暴露出数据驱动的评价函数或者保留基本的比较判断，至于判断后的连锁状态修改则由程序员解决。

​	DRY（Don't repeat yourself）原则,通用的逻辑要写成方法，通用的数据要能够继承

​	开发工具生成数据，通过采样还能生成概率性的数据。在python3中itertools.product能够生成具备各种条件的数据



### 面向对象

​	扩展类之间的合作包含两种方式继承和分层（component），区别在于描述是‘是’还是‘有’。类的内部则是用Conpect（包括属性和方法）描述。

插播一个面试题：我在设计活动列表使用的是二叉树，由于活动会在更新时变动，我就利用二叉树结构，方便排序更新，面试官问我为什么不采用for循环，活动数据量很大么？我当时分析了两个数据结构的空间占用。妥协的承认for循环也更好。这种两面倒的回答方式表示采用这个数据结构只是为了炫技，其实树形结构具有比数组优秀的增删改和排序功能，而且活动日程表主要是排序变动，活动开启和关闭，对于查找功能需求不高。



​	自动单例模式中模板的构造函数中的this是指基类是指针，要求出子类的指针需要求偏移，通过对1虚构的对象强制转换成两种类型得到偏移。天龙项目中唯一对象使用的是全局类，这有三个缺点：

 	1. 使用时需要extern引入
		2. 没有设定访问权限，外部能随意改动
		3. 无法按照意愿创建和销毁

UE4引擎中使用的是传统定义单例的方法，静态变量+create+destroy方法

### 一个通用的函数绑定接口

​	脚本引擎和网络消息传送,本书中是通过一个{“FunName”，ID，FunPtr}数据结构注册的，在项目中我们利用的Tolua是通过{“FunName”，FunPtr}进行绑定，调用的方法类似lua调用C函数lua_register(L,"")[ToLua绑定原理](./Tolua绑定原理与优化建议) 。

​	出于安全调用，希望能通过解析function的结构自动生成函数注册数组，C++语言在编译期间可以获得所有期望的全部信息，但是无法通过代码访问，在生成exe文件时又会被删除。提供一个路线是通过PDB（调试符号库）查询所需信息，但是不能要游戏附带调试符号，此外没有简单的方法区别那些是输出函数。

​	利用mangle和unmangle可以通过EXE 输出表项获取文本形式的函数原型，然后进行文本分析得到名称类型和调用约定信息， 将结果存储的g_Functions数据结构中注册

​	这里介绍的是关于Function的解析，如果对整个类进行分析则是需要建立类型系统，前面Lua绑定实现的类型系统是通过userdata，UE4的类型系统参考。

[UE4 Inside]: https://zhuanlan.zhihu.com/p/24319968	"类型系统"

### 基于通用索引的资源管理器

​	按需创建和删除资源，而且能简单、高效使用资源。指针的方式提供资源容易且方便，但是开发者可以随意的复制指针而不通知管理器，在资源删除时会产生空指针问题。这里不通过创造智能指针解决问题，二是通过抽象一层索引类（Handle）

​	Handle类包含索引两部分：Index表示：唯一性标识可以索引资源在数据库中的位置 。    Magic表示：申请资源时自动增长的数字，由于资源释放魔术数会清零，可以通过比较管理器中魔术数部分与handle中是否一致来判断资源是否有效。

​	HandleMgr类中提供三个方法：申请Acquire，释放Release，解析Handle Dereference。

​	天龙架构由于使用的是Unity引擎，所以资源管理是由引擎负责。那Unity是如何进行资源管理的呢？它提供了3种资源读取方式：

- - Resources:支持编辑器模式和发布模式
  - AssetDatabase:仅支持编辑器模式
  - AssetBundle:支持编辑器模式和发布模式

- 可以利用const_cast提供不可修改数值的方法
介绍完资源管理器，再来介绍下资源管理器可以完成的工作，当资源的基类提供创建，删除，重新加载等基础操作，提供一些资源属性（例如优先级，大小，创建时间）则可以实现实用的内存管理。换出的资源并不是类中的所有数据，而只是资源中最大的那部分（如位图，声音缓冲）保留类中必要的信息（例如文件路径，文件信息）

### 如何快速的加载数据

简单的也是有效的，文中给到的方法是将带有成员函数的类保存，1.**保存的数据**中不能包含指针，2.而且他们必须是非静态的成员变量，3.类中不能有虚函数，因为如果虚函数表被无效数据覆盖会调用任何位置代码。4.文中快速主要体现在是将存储的数据处理成了最终使用的格式，不需要进行转换，直接利用memcpy从硬盘中读取道游戏中使用。

### 帧内存分配系统

why：如果利用melloc和new内存分配系统最大问题是容易造成内存碎片。which：基于帧的内存管理器，how:适用于游戏和关卡初始化模块。能够快速加载3D图形数据和声音数据。

原理：利用melloc分配一块内存，大小为资源管理器管理总资源大小+内存对齐数，利用向下向上增长的两个堆进行分配管理。

既然以堆栈顺序存入，释放时则也需要以顺序释放.对于多种资源类型可以使用多种帧来加载，然后通过struct主帧联系到一起。

句柄：需要哪些信息去定位位置。所有信息的结构称为句柄

### 简单快速的位数组

what 类似于数组使用位操作，隐藏繁琐的细节

### Assert使用技巧

能供准确定位问题位置，输出详细信息，频繁的断言能只触发一次，生成格式化的报告

### 实时统计和游戏内调试

类似于引擎中输出帧率，三角面，摄像机等信息的功能，当然引擎中提供了更加强大的调试工具，unity通过Frame Debugger 、Profiler（剖析）工具完成性能分析。lua则是通过lua  Profiler工具来排查性能问题。

UE4中的分析工具参考[UE4开发者工具](https://docs.unrealengine.com/zh-CN/Engine/Tools/DevTools/index.html)



## 第二章

### 可预测随机数

利用随机数种子生成可预测数的序列，分成宏无限分解和微无限分解，《无人深空》则是典型代表。先通过一个随机种子生成恒星位置，再通过坐标和成唯一种子（x + x*y）进行随机再对行星最大种类数量取余得到行星数量，进一步细化，根据地图大小随机生成水还是陆地。

### 小波（wavelets）：理论与压缩

类似于金字塔结构（二叉树），通过取均值一级一级递增，保存与均值的差（细节系数）以及最高级的转换因数，则可以还原原来的数。这里保存数的个数虽然没有减少，但是数的大小被转换成了增量，可以缩小存储空间，达到压缩的效果。小波适合处理离散的值，以及是非周期函数傅里叶变换的替代方法。

1. 这里引用吴军的课程[语音和图像压缩的计算机科学原理](https://www.biji.com/article/xzYo2GPNq4W8VERnlJejyRBZbnw0d9 ) 先是利用谷歌的一道面试题提到计算机思维要敢于把看的懂得信息，变成看不懂的，但是没有任何损失的中间信息的做法，这是语音和图像处理的基础。

   第一步将语音和图像从直观的信号，变成人根本看不懂的频率信号。

   第二步根据压缩比例，把高品的信号过滤掉，只保留低频即可。当播放或显示时再将频率信号恢复即可。

2. 关于增量从吴军老师的信息压缩中有所介绍[信息增量：信息压缩中的保守主义原则](https://www.biji.com/article/R2Mo65zY4QZ3VnmorlKqEdNAa98jGB ) 介绍了如何利用信息的等价性压缩信息。除了保存增量的数值还要多加一位保存符号。在学习PeterNovig的程序设计课程也是采用保守做法，先是利用简单易懂的办法，不考虑性能完成问题涉及的各个概念（conpect），得到一个基础版（baseline），然后分析实现，找到效率更高的方案进行替换（少做无用功），优化代码结构。