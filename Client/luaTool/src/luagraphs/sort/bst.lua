---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangdongliang.
--- DateTime: 2019/3/12 17:15
---
--[[
	Create a new Binary Search Tree with the given keys. Be aware of the
	consequences of inserting already ordered data before you do this.
]]

local bst = {}
function bst:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

--function bst:new_multi(keys)
--    local new = self:new()
--    for i, v in ipairs(keys) do
--        new:insert(v)
--    end
--    return new
--end

--[[
	Insert a new key into a Binary Search tree. If replace evaluates to true,
	replace any existing equal key with the new one. Returns true or false
	to indicate if a replacement happened, and the node that was replaced or
	inserted
	note:default replace = true; key type is number ,参与比较的变量必须存在  ，错误的想法要想
]]
function bst:insert(key,value,replace)
    if not self.key then
        self.key = key
        self.value = value
        return false, self
    end
    if self.key == key then
        if replace then
            self.key = key
            self.value = value
            return true, self
        end
    elseif self.key > key then
        if not self.left then
            self.left = bst:new{parent=self, key=key,value=value }
            return false, self.left
        else
            return self.left:insert(key,value, replace)
        end
    else
        if not self.right then
            self.right = bst:new{parent=self, key=key, value=value}
            return false, self.right
        else
            return self.right:insert(key,value, replace)
        end
    end
end

--function bst:insert_multi(key, replace)
--    for i, v in ipairs(key) do
--        self:insert(v, replace)
--    end
--end

--[[
	Given the root node of a tree, find the smallest node on the tree. Return
	that node and it's key.
]]
function bst.first(node)
    while node.left do
        node = node.left
    end
    return node, node.key
end

--[[
	Given the root node of a tree, find the largest node on the tree. Return
	that node and it's key.
]]
function bst.last(node)
    while node.right do
        node = node.right
    end
    return node, node.key
end

--[[
	Return the next larger node and its key in the whole tree.
]]
function bst.next(node)
    if node.right then
        return node.right:first()
    end
    while node.parent do
        if node.parent.left == node then
            return node.parent, node.parent.key
        end
        node = node.parent
    end
end

--[[
	Return the next smaller node and its key in the whole tree
]]
function bst.previous(node)
    if node.left then
        return node.left:last()
    end
    while node.parent do
        if node.parent.right == node then
            return node.parent, node.parent.key
        end
        node = node.parent
    end
end

--[[
	Use in a for loop to iterate through all the nodes in a Binary Search
	Tree in sorted order.
]]
function bst:iter()
    local iter_function = self.first
    local node, key = self, nil
    return function ()
        node, key = iter_function(node)
        iter_function = self.next
        return node, key
    end
end

--[[
	Use in a for loop to iterate through all the nodes in a Binary Search
	Tree in reverse sorted order.
]]
function bst:rev_iter()
    local iter_function = self.last
    local node, key = self, nil
    return function ()
        node, key = iter_function(node)
        iter_function = self.previous
        return node, key
    end
end

--[[
	Determine whether a key already exists in a Binary Search Tree. Return
	the containing node and the key if it does. Else, returns false.
]]
function bst.search(node, key)
    if not node or next(node) == nil then
        return false
    elseif node.key > key then
        return bst.search(node.left, key)
    elseif node.key < key then
        return bst.search(node.right, key)
    end
    return node, node.key
end

--[[
	Return the number of direct children that node has. This will be either 0,
	1, or 2.
]]
local function count_children(node)
    local count = 0
    if node.left then
        count = count + 1
    end
    if node.right then
        count = count + 1
    end
    return count
end

--[[
	Delete a node with 0 or 1 direct child.
]]
local function bst_delete_simple(node)
    local replacement = node.left or node.right
    if node.parent == nil then
        if replacement then
            node.key = replacement.key
            node.value = replacement.value
            if replacement.left then
                node.left = replacement.left
                replacement.left.parent = node
            else
                node.left = nil
            end
            if replacement.right then
                node.right = replacement.right
                replacement.right.parent = node
            else
                node.right = nil
            end
            replacement.parent = nil
        else
            node.key = nil
            node.value = nil
        end
        return
    end
    if node == node.parent.right then
        node.parent.right = replacement
    else
        node.parent.left = replacement
    end
    if replacement then
        replacement.parent = node.parent
    end
    node.parent = nil
end

--[[
	Delete a node with 2 direct children.
]]
local function bst_delete_complex(node)
    local replacement = nil
    if math.random(2) == 1 then
        replacement = node:next()
    else
        replacement = node:previous(node)
    end
    node.key = replacement.key
    node.value = replacement.value
    bst_delete_simple(replacement)
end

--[[
	Delete a node with the given key from the tree. Returns true if the
	deletion occurred.
]]
function bst:delete(key)
    local to_delete = self:search(key)
    if not to_delete then
        return false
    end
    if count_children(to_delete) == 2 then
        bst_delete_complex(to_delete)
    else
        bst_delete_simple(to_delete)
    end
    return true
end

function bst:delete_multi(keys)
    for i, v in ipairs(keys) do
        self:delete(v)
    end
end

function bst:clear()
    local results = {};
    for n, v in self:iter() do
        table.insert(results, v)
    end
    for i, v in ipairs(results) do
        self:delete(v);
    end
end



function bst:__tostring()
    local queue = {}
    local results = {}
    table.insert(queue, self)
    while queue[1] do
        local dequeued = table.remove(queue, 1)
        table.insert(results, dequeued.key)
        if dequeued.left then
            table.insert(queue, dequeued.left)
        end
        if dequeued.right then
            table.insert(queue, dequeued.right)
        end
    end
    local as_strings = {}
    for i, v in ipairs(results) do
        table.insert(as_strings, tostring(v))
    end
    return table.concat(as_strings, " ")
end

return bst
