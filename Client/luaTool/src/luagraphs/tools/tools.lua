---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangdongliang.
--- DateTime: 2020/6/8 10:58
---
local M = {}

local mt = { __concat =
             function (a, f)
                 return function (...)
                     local input = {...}
                     if a.__pre then input = a:__pre(...) end
                     local res = {f(unpack(input))}
                     if a.__after then res = a:__after(res) end
                     return unpack(res)
                 end
             end
}

local function _wrap(pre, after)
    return function (...)
        return setmetatable({__pre = pre, __after = after, __paras = {...} }, mt)
    end
end

local function prewrap(pre)
    return _wrap(pre)
end
M.prewrap = prewrap

local function fullwrap(pre, after)
    return _wrap(pre, after)
end
M.fullwrap = fullwrap

local function afterwrap(after)
    return _wrap(nil, after)
end
M.afterwrap = afterwrap

local function _rawwrap(pre, after)
    return setmetatable({__pre=pre, __after=after}, mt)
end

local function raw_prewrap(pre)
    return _rawwrap(pre)
end
M.raw_prewrap = raw_prewrap

local function raw_fullwrap(pre, after)
    return _rawwrap(pre, after)
end
M.raw_fullwrap = raw_fullwrap

local function raw_afterwrap(after)
    return _rawwrap(nil, after)
end
M.raw_afterwrap = raw_afterwrap

--函数用时精确到s
local timer = raw_fullwrap(
        function (self, ...)
            self.begin = os.time()
            return {...}
        end,
        function (self, res)
            self.ends = os.time()
            print('用时',self.ends - self.begin)
            return res
        end
)

--输出调试信息 todo 在trace中添加变量控制缩进
local trace = raw_fullwrap(
        function (self, ...)
            local signature = debug.getinfo(2, "n").name..'('
            local paras = {...}
            for k, v in pairs(paras) do
                signature = signature .. v ..', '
            end
            signature = signature..')'
            if self.level == nil then
                self.level = 0
            end
            local indent = '    '
            for i = 0, self.level do
                indent = indent..'    '
            end
            print(string.format("%s--> %s",indent, signature))
            self.level = self.level + 1
            return {...}
        end,
        function (self, res)
            local debugInfo = debug.getinfo(2, "n")
            local signature = debugInfo.name
            local indent = '    '
            for i = 0, self.level - 1 do
                indent = indent..'    '
            end
            print(string.format("%s<-- %s == %s",indent, signature, res[1]))
            self.level = self.level - 1
            return res
        end
)

trace = raw_fullwrap(nil, nil)

--校验输入参数
local multiply_input = prewrap(function (self, ...)
    local paras = {...}
    for k, v in pairs(paras) do
        paras[k] = paras[k]*self.__paras[1]
    end
    return paras
end)
--输入输出类型检查
local typecheck = fullwrap(
        function (self, ...)
            local paras = {...}
            for k, v in pairs(self.__paras) do
                if v == "->" then break end
                if type(paras[k]) ~= v then
                    error(string.format("input type error, expect:%s got:%s",
                            v, type(paras[k])), 3)
                end
            end
            return paras
        end,
        function (self, res)
            local idx
            for k, v in pairs(self.__paras) do
                if v == "->" then
                    idx = k
                    break
                end
            end
            for k, v in pairs(res) do
                if type(v) ~= self.__paras[idx+k] then
                    error(string.format("result type error, expect:%s, got:%s",
                            self.__paras[idx+k], type(v)), 3)
                end
            end
            return res
        end
)

local foo =
typecheck("number", "number", "->", "number") ..
        multiply_input(3) ..
        timer ..
        function (x, y)
            local something_fool = function ()
                for i = 1, 100000000 do
                    y = math.sin(2)
                end
            end; something_fool()
            --return "hello"
            return x^2+y
        end



--print(foo(100, 1))
function test(x)
    local j = 0
    for i=1,100 do
        for i = 1, 10000 do
            j = j + 1
        end
    end
end



local test = trace ..
    function (x,y)
        local j = 0
        for i=1,100 do
            for i = 1, 100 do
                j = j + 1
            end
        end

        return 5
    end

local test1 = trace ..
        function (x,y)
            local j = 0
            for i=1,100 do
                for i = 1, 100 do
                    j = j + 1
                end
            end
            test(23,4)
            test(18,12)
            return 6
        end

test1(100,1)
test(2,3)
--local function myFunc(x,v)
--    print(debug.getinfo(1, "n").name);
--end
